import sharp from 'sharp';
import { checkExt, createNewAssetAt } from '../core/index.js';
import { mipmapSharp } from './utils/mipmapSharp.js';
import { resolveOptions } from './utils/resolveOptions.js';
const defaultMipmapOptions = {
    template: '@%%x',
    resolutions: { default: 1, low: 0.5 },
    fixedResolution: 'default',
    sharpOptions: {},
};
export function mipmap(_options = {}) {
    const mipmap = resolveOptions(_options, defaultMipmapOptions);
    return {
        folder: true,
        name: 'mipmap',
        defaultOptions: {
            ...mipmap,
        },
        tags: {
            fix: 'fix',
            nomip: 'nomip',
        },
        test(asset, options) {
            return options && checkExt(asset.path, '.png', '.jpg', '.jpeg') && !asset.allMetaData[this.tags.nomip];
        },
        async transform(asset, options) {
            const shouldMipmap = mipmap && !asset.allMetaData[this.tags.fix];
            let processedImages;
            const image = {
                format: asset.extension,
                resolution: 1,
                sharpImage: sharp(asset.buffer),
            };
            const { resolutions, fixedResolution, sharpOptions } = options || this.defaultOptions;
            const fixedResolutions = {
                [fixedResolution]: resolutions[fixedResolution],
            };
            const largestResolution = Math.max(...Object.values(resolutions));
            try {
                if (shouldMipmap) {
                    const resolutionHash = asset.allMetaData[this.tags.fix] ? fixedResolutions : resolutions;
                    image.resolution = largestResolution;
                    processedImages = await mipmapSharp(image, resolutionHash, largestResolution, sharpOptions);
                }
                else {
                    image.resolution = fixedResolutions[fixedResolution];
                    processedImages =
                        image.resolution === 1
                            ? [image]
                            : (processedImages = await mipmapSharp(image, fixedResolutions, largestResolution, sharpOptions));
                }
            }
            catch (error) {
                throw new Error(`[AssetPack][mipmap] Failed to mipmap image: ${asset.path} - ${error}`);
            }
            // now create our new assets
            const newAssets = processedImages.map((data) => {
                let resolution = '';
                if (options) {
                    resolution = options.template.replace('%%', `${data.resolution}`);
                    resolution = data.resolution === 1 ? '' : resolution;
                }
                const end = `${resolution}${data.format}`;
                const filename = asset.filename.replace(/\.[^/.]+$/, end);
                const newAsset = createNewAssetAt(asset, filename);
                return newAsset;
            });
            const promises = processedImages.map((image, i) => image.sharpImage.toBuffer().then((buffer) => {
                newAssets[i].buffer = buffer;
            }));
            await Promise.all(promises);
            return newAssets;
        },
    };
}
//# sourceMappingURL=mipmap.js.map