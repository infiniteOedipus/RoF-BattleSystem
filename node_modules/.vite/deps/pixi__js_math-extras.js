import {
  ObservablePoint,
  Point,
  Rectangle
} from "./chunk-3MWCA7XH.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/pixi.js/lib/math-extras/pointExtras.mjs
var pointExtraMixins = {
  add(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x + other.x;
    outPoint.y = this.y + other.y;
    return outPoint;
  },
  subtract(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x - other.x;
    outPoint.y = this.y - other.y;
    return outPoint;
  },
  multiply(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * other.x;
    outPoint.y = this.y * other.y;
    return outPoint;
  },
  multiplyScalar(scalar, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * scalar;
    outPoint.y = this.y * scalar;
    return outPoint;
  },
  dot(other) {
    return this.x * other.x + this.y * other.y;
  },
  cross(other) {
    return this.x * other.y - this.y * other.x;
  },
  normalize(outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
    outPoint.x = this.x / magnitude;
    outPoint.y = this.y / magnitude;
    return outPoint;
  },
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y;
  },
  project(onto, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);
    outPoint.x = onto.x * normalizedScalarProjection;
    outPoint.y = onto.y * normalizedScalarProjection;
    return outPoint;
  },
  reflect(normal, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const dotProduct = this.x * normal.x + this.y * normal.y;
    outPoint.x = this.x - 2 * dotProduct * normal.x;
    outPoint.y = this.y - 2 * dotProduct * normal.y;
    return outPoint;
  }
};

// node_modules/pixi.js/lib/math-extras/rectangleExtras.mjs
var rectangleExtraMixins = {
  containsRect(other) {
    if (other.width <= 0 || other.height <= 0) {
      return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;
    }
    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;
  },
  equals(other) {
    if (other === this) {
      return true;
    }
    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  },
  intersection(other, outRect) {
    if (!outRect) {
      outRect = new Rectangle();
    }
    const x0 = this.x < other.x ? other.x : this.x;
    const x1 = this.right > other.right ? other.right : this.right;
    if (x1 <= x0) {
      outRect.x = outRect.y = outRect.width = outRect.height = 0;
      return outRect;
    }
    const y0 = this.y < other.y ? other.y : this.y;
    const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;
    if (y1 <= y0) {
      outRect.x = outRect.y = outRect.width = outRect.height = 0;
      return outRect;
    }
    outRect.x = x0;
    outRect.y = y0;
    outRect.width = x1 - x0;
    outRect.height = y1 - y0;
    return outRect;
  },
  union(other, outRect) {
    if (!outRect) {
      outRect = new Rectangle();
    }
    const x1 = Math.min(this.x, other.x);
    const x2 = Math.max(this.x + this.width, other.x + other.width);
    const y1 = Math.min(this.y, other.y);
    const y2 = Math.max(this.y + this.height, other.y + other.height);
    outRect.x = x1;
    outRect.y = y1;
    outRect.width = x2 - x1;
    outRect.height = y2 - y1;
    return outRect;
  }
};

// node_modules/pixi.js/lib/math-extras/init.mjs
Object.assign(Point.prototype, pointExtraMixins);
Object.assign(ObservablePoint.prototype, pointExtraMixins);
Object.assign(Rectangle.prototype, rectangleExtraMixins);
//# sourceMappingURL=pixi__js_math-extras.js.map
