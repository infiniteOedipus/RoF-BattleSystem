{
  "version": 3,
  "sources": ["../../pixi.js/src/math-extras/pointExtras.ts", "../../pixi.js/src/math-extras/rectangleExtras.ts", "../../pixi.js/src/math-extras/init.ts"],
  "sourcesContent": ["import { Point } from '../maths/point/Point';\n\nimport type { PointData } from '../maths/point/PointData';\n\n/** @internal */\nexport const pointExtraMixins: any = {\n    add<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n    subtract<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n    multiply<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n    multiplyScalar<T extends PointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n    dot(other: PointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n    cross(other: PointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n    normalize<T extends PointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n    project<T extends PointData>(onto: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n    reflect<T extends PointData>(normal: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    }\n};\n", "import { Rectangle } from '../maths/shapes/Rectangle';\n\n/** @internal */\nexport const rectangleExtraMixins: Partial<Rectangle> = {\n    containsRect(other: Rectangle): boolean\n    {\n        if (other.width <= 0 || other.height <= 0)\n        {\n            return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n        }\n\n        return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n    },\n    equals(other: Rectangle): boolean\n    {\n        if (other === this)\n        {\n            return true;\n        }\n\n        return (\n            other\n            && this.x === other.x\n            && this.y === other.y\n            && this.width === other.width\n            && this.height === other.height\n        );\n    },\n    intersection<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x0 = this.x < other.x ? other.x : this.x;\n        const x1 = this.right > other.right ? other.right : this.right;\n\n        if (x1 <= x0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        const y0 = this.y < other.y ? other.y : this.y;\n        const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n        if (y1 <= y0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        outRect.x = x0;\n        outRect.y = y0;\n        outRect.width = x1 - x0;\n        outRect.height = y1 - y0;\n\n        return outRect;\n    },\n    union<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x1 = Math.min(this.x, other.x);\n        const x2 = Math.max(this.x + this.width, other.x + other.width);\n        const y1 = Math.min(this.y, other.y);\n        const y2 = Math.max(this.y + this.height, other.y + other.height);\n\n        outRect.x = x1;\n        outRect.y = y1;\n        outRect.width = x2 - x1;\n        outRect.height = y2 - y1;\n\n        return outRect;\n    },\n};\n", "import { ObservablePoint } from '../maths/point/ObservablePoint';\nimport { Point } from '../maths/point/Point';\nimport { Rectangle } from '../maths/shapes/Rectangle';\nimport { pointExtraMixins } from './pointExtras';\nimport { rectangleExtraMixins } from './rectangleExtras';\n\nObject.assign(Point.prototype, pointExtraMixins);\nObject.assign(ObservablePoint.prototype, pointExtraMixins);\nObject.assign(Rectangle.prototype, rectangleExtraMixins);\n"],
  "mappings": "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",
  "names": []
}
