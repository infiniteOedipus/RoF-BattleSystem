/*!
 * @pixi/math-extras - v7.4.3
 * Compiled Thu, 06 Mar 2025 14:58:55 UTC
 *
 * @pixi/math-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI = this.PIXI || {};
var _pixi_math_extras = function(exports, core) {
  "use strict";
  const mixins = {
    /**
     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method add
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to add to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.
     */
    /**
     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method add
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to add to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.
     */
    add(other, outPoint) {
      return outPoint || (outPoint = new core.Point()), outPoint.x = this.x + other.x, outPoint.y = this.y + other.y, outPoint;
    },
    /**
     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method subtract
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to subtract to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.
     */
    /**
     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method subtract
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to subtract to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.
     */
    subtract(other, outPoint) {
      return outPoint || (outPoint = new core.Point()), outPoint.x = this.x - other.x, outPoint.y = this.y - other.y, outPoint;
    },
    /**
     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method multiply
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to multiply with `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
     */
    /**
     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method multiply
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to multiply with `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
     */
    multiply(other, outPoint) {
      return outPoint || (outPoint = new core.Point()), outPoint.x = this.x * other.x, outPoint.y = this.y * other.y, outPoint;
    },
    /**
     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method multiplyScalar
     * @memberof PIXI.Point#
     * @param {number} scalar - The number to multiply both components of `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.
     */
    /**
     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method multiplyScalar
     * @memberof PIXI.ObservablePoint#
     * @param {number} scalar - The number to multiply both components of `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.
     */
    multiplyScalar(scalar, outPoint) {
      return outPoint || (outPoint = new core.Point()), outPoint.x = this.x * scalar, outPoint.y = this.y * scalar, outPoint;
    },
    /**
     * Computes the dot product of `other` with `this` point.
     * The dot product is the sum of the products of the corresponding components of two vectors.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method dot
     * @memberof PIXI.Point#
     * @param {IPointData} other - The other point to calculate the dot product with `this`.
     * @returns {number} The result of the dot product. This is an scalar value.
     */
    /**
     * Computes the dot product of `other` with `this` point.
     * The dot product is the sum of the products of the corresponding components of two vectors.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method dot
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The other point to calculate the dot product with `this`.
     * @returns {number} The result of the dot product. This is an scalar value.
     */
    dot(other) {
      return this.x * other.x + this.y * other.y;
    },
    /**
     * Computes the cross product of `other` with `this` point.
     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read "a cross b"),
     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
     * the result becomes a vector that will only have magnitude on the z axis.
     *
     * This function returns the z component of the cross product of the two points.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method cross
     * @memberof PIXI.Point#
     * @param {IPointData} other - The other point to calculate the cross product with `this`.
     * @returns {number} The z component of the result of the cross product.
     */
    /**
     * Computes the cross product of `other` with `this` point.
     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read "a cross b"),
     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
     * the result becomes a vector that will only have magnitude on the z axis.
     *
     * This function returns the z component of the cross product of the two points.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method cross
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The other point to calculate the cross product with `this`.
     * @returns {number} The z component of the result of the cross product.
     */
    cross(other) {
      return this.x * other.y - this.y * other.x;
    },
    /**
     * Computes a normalized version of `this` point.
     *
     * A normalized vector is a vector of magnitude (length) 1
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method normalize
     * @memberof PIXI.Point#
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The normalized point.
     */
    /**
     * Computes a normalized version of `this` point.
     *
     * A normalized vector is a vector of magnitude (length) 1
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method normalize
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The normalized point.
     */
    normalize(outPoint) {
      outPoint || (outPoint = new core.Point());
      const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
      return outPoint.x = this.x / magnitude, outPoint.y = this.y / magnitude, outPoint;
    },
    /**
     * Computes the magnitude of this point (Euclidean distance from 0, 0).
     *
     * Defined as the square root of the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method magnitude
     * @memberof PIXI.Point#
     * @returns {number} The magnitude (length) of the vector.
     */
    /**
     * Computes the magnitude of this point (Euclidean distance from 0, 0).
     *
     * Defined as the square root of the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method magnitude
     * @memberof PIXI.ObservablePoint#
     * @returns {number} The magnitude (length) of the vector.
     */
    magnitude() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    /**
     * Computes the square magnitude of this point.
     * If you are comparing the lengths of vectors, you should compare the length squared instead
     * as it is slightly more efficient to calculate.
     *
     * Defined as the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method magnitudeSquared
     * @memberof PIXI.Point#
     * @returns {number} The magnitude squared (length squared) of the vector.
     */
    /**
     * Computes the square magnitude of this point.
     * If you are comparing the lengths of vectors, you should compare the length squared instead
     * as it is slightly more efficient to calculate.
     *
     * Defined as the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method magnitudeSquared
     * @memberof PIXI.ObservablePoint#
     * @returns {number} The magnitude squared (length squared) of the vector.
     */
    magnitudeSquared() {
      return this.x * this.x + this.y * this.y;
    },
    /**
     * Computes vector projection of `this` on `onto`.
     *
     * Imagine a light source, parallel to `onto`, above `this`.
     * The light would cast rays perpendicular to `onto`.
     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method project
     * @memberof PIXI.Point#
     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `this` on `onto` projection.
     */
    /**
     * Computes vector projection of `this` on `onto`.
     *
     * Imagine a light source, parallel to `onto`, above `this`.
     * The light would cast rays perpendicular to `onto`.
     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method project
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `this` on `onto` projection.
     */
    project(onto, outPoint) {
      outPoint || (outPoint = new core.Point());
      const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);
      return outPoint.x = onto.x * normalizedScalarProjection, outPoint.y = onto.y * normalizedScalarProjection, outPoint;
    },
    /**
     * Reflects `this` vector off of a plane orthogonal to `normal`.
     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
     *
     * Imagine a light source bouncing onto a mirror.
     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
     * `this.reflect(normal)` is the reflection of `this` on that mirror.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method reflect
     * @memberof PIXI.Point#
     * @param {IPointData} normal - The normal vector of your reflecting plane.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The reflection of `this` on your reflecting plane.
     */
    /**
     * Reflects `this` vector off of a plane orthogonal to `normal`.
     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
     *
     * Imagine a light source bouncing onto a mirror.
     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
     * `this.reflect(normal)` is the reflection of `this` on that mirror.
     *
     * _Note: Only available with **@pixi/math-extras**._
     * @method reflect
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} normal - The normal vector of your reflecting plane.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The reflection of `this` on your reflecting plane.
     */
    reflect(normal, outPoint) {
      outPoint || (outPoint = new core.Point());
      const dotProduct = this.x * normal.x + this.y * normal.y;
      return outPoint.x = this.x - 2 * dotProduct * normal.x, outPoint.y = this.y - 2 * dotProduct * normal.y, outPoint;
    }
  };
  Object.assign(core.Point.prototype, mixins), Object.assign(core.ObservablePoint.prototype, mixins), core.Rectangle.prototype.containsRect = function(other) {
    return other.width <= 0 || other.height <= 0 ? other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom : other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;
  }, core.Rectangle.prototype.equals = function(other) {
    return other === this ? !0 : other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  }, core.Rectangle.prototype.intersection = function(other, outRect) {
    outRect || (outRect = new core.Rectangle());
    const x0 = this.x < other.x ? other.x : this.x, x1 = this.right > other.right ? other.right : this.right;
    if (x1 <= x0)
      return outRect.x = outRect.y = outRect.width = outRect.height = 0, outRect;
    const y0 = this.y < other.y ? other.y : this.y, y1 = this.bottom > other.bottom ? other.bottom : this.bottom;
    return y1 <= y0 ? (outRect.x = outRect.y = outRect.width = outRect.height = 0, outRect) : (outRect.x = x0, outRect.y = y0, outRect.width = x1 - x0, outRect.height = y1 - y0, outRect);
  }, core.Rectangle.prototype.union = function(other, outRect) {
    outRect || (outRect = new core.Rectangle());
    const x1 = Math.min(this.x, other.x), x2 = Math.max(this.x + this.width, other.x + other.width), y1 = Math.min(this.y, other.y), y2 = Math.max(this.y + this.height, other.y + other.height);
    return outRect.x = x1, outRect.y = y1, outRect.width = x2 - x1, outRect.height = y2 - y1, outRect;
  };
  function floatEqual(a, b, epsilon = Number.EPSILON) {
    return a === b ? !0 : Math.abs(a - b) < epsilon;
  }
  function genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {
    outPoint || (outPoint = new core.Point());
    const dxa = aEnd.x - aStart.x, dya = aEnd.y - aStart.y, dxb = bEnd.x - bStart.x, dyb = bEnd.y - bStart.y, denominator = dyb * dxa - dxb * dya;
    if (floatEqual(denominator, 0))
      return outPoint.x = NaN, outPoint.y = NaN, outPoint;
    const ua = (dxb * (aStart.y - bStart.y) - dyb * (aStart.x - bStart.x)) / denominator, ub = (dxa * (aStart.y - bStart.y) - dya * (aStart.x - bStart.x)) / denominator;
    return !isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1) ? (outPoint.x = NaN, outPoint.y = NaN, outPoint) : (outPoint.x = aStart.x + ua * dxa, outPoint.y = bStart.y + ub * dyb, outPoint);
  }
  function lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
    return genericLineIntersection(aStart, aEnd, bStart, bEnd, !0, outPoint);
  }
  function segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
    return genericLineIntersection(aStart, aEnd, bStart, bEnd, !1, outPoint);
  }
  return exports.floatEqual = floatEqual, exports.lineIntersection = lineIntersection, exports.segmentIntersection = segmentIntersection, exports;
}({}, PIXI);
Object.assign(this.PIXI, _pixi_math_extras);
//# sourceMappingURL=math-extras.js.map
