"use strict";
var core = require("@pixi/core");
require("./pointExtras.js");
require("./rectangleExtras.js");
function floatEqual(a, b, epsilon = Number.EPSILON) {
  return a === b ? !0 : Math.abs(a - b) < epsilon;
}
function genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {
  outPoint || (outPoint = new core.Point());
  const dxa = aEnd.x - aStart.x, dya = aEnd.y - aStart.y, dxb = bEnd.x - bStart.x, dyb = bEnd.y - bStart.y, denominator = dyb * dxa - dxb * dya;
  if (floatEqual(denominator, 0))
    return outPoint.x = NaN, outPoint.y = NaN, outPoint;
  const ua = (dxb * (aStart.y - bStart.y) - dyb * (aStart.x - bStart.x)) / denominator, ub = (dxa * (aStart.y - bStart.y) - dya * (aStart.x - bStart.x)) / denominator;
  return !isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1) ? (outPoint.x = NaN, outPoint.y = NaN, outPoint) : (outPoint.x = aStart.x + ua * dxa, outPoint.y = bStart.y + ub * dyb, outPoint);
}
function lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, !0, outPoint);
}
function segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, !1, outPoint);
}
exports.floatEqual = floatEqual;
exports.lineIntersection = lineIntersection;
exports.segmentIntersection = segmentIntersection;
//# sourceMappingURL=index.js.map
