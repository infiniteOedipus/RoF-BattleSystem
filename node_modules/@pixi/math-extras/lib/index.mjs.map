{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["/// <reference path=\"../global.d.ts\" />\nimport { Point } from '@pixi/core';\nimport './pointExtras';\nimport './rectangleExtras';\n\nimport type { IPointData } from '@pixi/core';\n\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @returns {boolean} Returns `true` if the difference between the values is less than `Math.EPSILON`; otherwise `false`.\n */\nexport function floatEqual(a: number, b: number): boolean;\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than a given epsilon.\n * A good epsilon would be the N% of the largest of the two values or `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @param {number} epsilon - The epsilon to compare to.\n * The larger the epsilon, the easier for the numbers to be considered equals.\n * @returns {boolean} Returns `true` if the difference between the values is less than the given epsilon;\n * otherwise `false`.\n */\nexport function floatEqual(a: number, b: number, epsilon: number): boolean;\nexport function floatEqual(a: number, b: number, epsilon: number = Number.EPSILON): boolean\n{\n    if (a === b)\n    {\n        return true;\n    }\n\n    const diff = Math.abs(a - b);\n\n    return diff < epsilon;\n}\n\n/**\n * Generic line or segment intersection.\n * A line can intersect outside the two points defining it, the segment can't.\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param isLine - Set to true if you want Line (unbounded) intersection.\n * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines/segments intersect or a `NaN` Point.\n */\nfunction genericLineIntersection<T extends IPointData>(\n    aStart: IPointData,\n    aEnd: IPointData,\n    bStart: IPointData,\n    bEnd: IPointData,\n    isLine: boolean,\n    outPoint?: T): T\n{\n    if (!outPoint)\n    {\n        outPoint = new Point() as IPointData as T;\n    }\n\n    const dxa = aEnd.x - aStart.x;\n    const dya = aEnd.y - aStart.y;\n    const dxb = bEnd.x - bStart.x;\n    const dyb = bEnd.y - bStart.y;\n\n    // In order to find the position of the intersection in respect to the line segments, we can define lines\n    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.\n    // both `ua` and `ub` formula share the same denominator so it is only calculated once.\n\n    const denominator = ((dyb * dxa) - (dxb * dya));\n\n    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.\n    if (floatEqual(denominator, 0))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.\n    const ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;\n    const ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;\n\n    // Line intersection extends beyond the bounds of the segment.\n    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0\n    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    outPoint.x = aStart.x + (ua * dxa);\n    outPoint.y = bStart.y + (ub * dyb);\n\n    return outPoint;\n}\n\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @returns {IPointData} The point where the lines intersect.\n */\nexport function lineIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines intersect or a `NaN` Point.\n */\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);\n}\n\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @returns {IPointData} The point where the segments intersect.\n */\nexport function segmentIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the segments intersect or a `NaN` Point.\n */\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);\n}\n"],"names":[],"mappings":";;;AAgCO,SAAS,WAAW,GAAW,GAAW,UAAkB,OAAO,SAC1E;AACI,SAAI,MAAM,IAEC,KAGE,KAAK,IAAI,IAAI,CAAC,IAEb;AAClB;AAcA,SAAS,wBACL,QACA,MACA,QACA,MACA,QACA,UACJ;AACS,eAED,WAAW,IAAI,MAAM;AAGnB,QAAA,MAAM,KAAK,IAAI,OAAO,GACtB,MAAM,KAAK,IAAI,OAAO,GACtB,MAAM,KAAK,IAAI,OAAO,GACtB,MAAM,KAAK,IAAI,OAAO,GAMtB,cAAgB,MAAM,MAAQ,MAAM;AAGtC,MAAA,WAAW,aAAa,CAAC;AAEzB,WAAA,SAAS,IAAI,KACb,SAAS,IAAI,KAEN;AAIL,QAAA,MAAO,OAAO,OAAO,IAAI,OAAO,KAAO,OAAO,OAAO,IAAI,OAAO,MAAO,aACvE,MAAO,OAAO,OAAO,IAAI,OAAO,KAAO,OAAO,OAAO,IAAI,OAAO,MAAO;AAI7E,SAAI,CAAC,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,MAE/C,SAAS,IAAI,KACb,SAAS,IAAI,KAEN,aAGX,SAAS,IAAI,OAAO,IAAK,KAAK,KAC9B,SAAS,IAAI,OAAO,IAAK,KAAK,KAEvB;AACX;AAgCO,SAAS,iBACO,QAAoB,MAAkB,QAAoB,MAAkB,UACnG;AACI,SAAO,wBAAwB,QAAQ,MAAM,QAAQ,MAAM,IAAM,QAAQ;AAC7E;AAgCO,SAAS,oBACO,QAAoB,MAAkB,QAAoB,MAAkB,UACnG;AACI,SAAO,wBAAwB,QAAQ,MAAM,QAAQ,MAAM,IAAO,QAAQ;AAC9E;"}