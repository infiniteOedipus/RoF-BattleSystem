import fs from 'fs-extra';
import { BuildReporter, path, stripTags } from '../core/index.js';
export function pixiManifest(_options = {}) {
    return {
        name: 'pixi-manifest',
        defaultOptions: {
            output: 'manifest.json',
            createShortcuts: false,
            trimExtensions: false,
            includeMetaData: true,
            legacyMetaDataOutput: true,
            nameStyle: 'short',
            ..._options,
        },
        tags: {
            manifest: 'm',
            mIgnore: 'mIgnore',
        },
        async finish(asset, options, pipeSystem) {
            const newFileName = path.dirname(options.output) === '.'
                ? path.joinSafe(pipeSystem.outputPath, options.output)
                : options.output;
            const defaultBundle = {
                name: 'default',
                assets: [],
            };
            const manifest = {
                bundles: [defaultBundle],
            };
            collectAssets(asset, options, pipeSystem.outputPath, pipeSystem.entryPath, manifest.bundles, defaultBundle, this.tags, pipeSystem.internalMetaData);
            filterUniqueNames(manifest, options);
            await fs.writeJSON(newFileName, manifest, { spaces: 2 });
        },
    };
}
function filterUniqueNames(manifest, options) {
    const nameMap = new Map();
    const isNameStyleShort = options.nameStyle !== 'relative';
    const bundleNames = new Set();
    const duplicateBundleNames = new Set();
    manifest.bundles.forEach((bundle) => {
        if (isNameStyleShort) {
            if (bundleNames.has(bundle.name)) {
                duplicateBundleNames.add(bundle.name);
                BuildReporter.warn(`[AssetPack][manifest] Duplicate bundle name '${bundle.name}'. All bundles with that name will be renamed to their relative name instead.`);
            }
            else {
                bundleNames.add(bundle.name);
            }
        }
        bundle.assets.forEach((asset) => nameMap.set(asset, asset.alias));
    });
    const arrays = Array.from(nameMap.values());
    const sets = arrays.map((arr) => new Set(arr));
    const uniqueArrays = arrays.map((arr, i) => arr.filter((x) => sets.every((set, j) => j === i || !set.has(x))));
    manifest.bundles.forEach((bundle) => {
        if (isNameStyleShort) {
            // Switch to relative bundle name to avoid duplications
            if (duplicateBundleNames.has(bundle.name)) {
                bundle.name = bundle.relativeName ?? bundle.name;
            }
        }
        bundle.assets.forEach((asset) => {
            const names = nameMap.get(asset);
            asset.alias = uniqueArrays.find((arr) => arr.every((x) => names.includes(x)));
        });
    });
}
function getRelativeBundleName(asset, entryPath) {
    let name = asset.filename;
    let parent = asset.parent;
    // Exclude assets the paths of which equal to the entry path
    while (parent && parent.path !== entryPath) {
        name = `${parent.filename}/${name}`;
        parent = parent.parent;
    }
    return stripTags(name);
}
function collectAssets(asset, options, outputPath = '', entryPath = '', bundles, bundle, tags, internalTags) {
    if (asset.skip)
        return;
    // an item may have been deleted, so we don't want to add it to the manifest!
    if (asset.state === 'deleted')
        return;
    let localBundle = bundle;
    if (asset.metaData[tags.manifest]) {
        localBundle = {
            name: options.nameStyle === 'relative' ? getRelativeBundleName(asset, entryPath) : stripTags(asset.filename),
            assets: [],
        };
        // This property helps rename duplicate bundle declarations
        // Also, mark it as non-enumerable to prevent fs from including it into output
        if (options.nameStyle !== 'relative') {
            Object.defineProperty(localBundle, 'relativeName', {
                enumerable: false,
                get() {
                    return getRelativeBundleName(asset, entryPath);
                },
            });
        }
        bundles.push(localBundle);
    }
    const bundleAssets = localBundle.assets;
    const finalAssets = asset.getFinalTransformedChildren();
    if (asset.transformChildren.length > 0) {
        const finalManifestAssets = finalAssets.filter((finalAsset) => !finalAsset.inheritedMetaData[tags.mIgnore]);
        if (finalManifestAssets.length === 0)
            return;
        const metadata = {
            tags: { ...asset.getInternalMetaData(internalTags) },
            ...asset.getPublicMetaData(internalTags),
        };
        if (options.legacyMetaDataOutput) {
            metadata.tags = asset.allMetaData;
        }
        bundleAssets.push({
            alias: getShortNames(stripTags(path.relative(entryPath, asset.path)), options),
            src: finalManifestAssets
                .map((finalAsset) => path.relative(outputPath, finalAsset.path))
                .sort((a, b) => b.localeCompare(a)),
            data: options.includeMetaData ? metadata : undefined,
        });
    }
    asset.children.forEach((child) => {
        collectAssets(child, options, outputPath, entryPath, bundles, localBundle, tags, internalTags);
    });
    // for all assets.. check for atlas and remove them from the bundle..
}
function getShortNames(name, options) {
    const createShortcuts = options.createShortcuts;
    const trimExtensions = options.trimExtensions;
    const allNames = [];
    allNames.push(name);
    trimExtensions && allNames.push(path.trimExt(name));
    createShortcuts && allNames.push(path.basename(name));
    createShortcuts && trimExtensions && allNames.push(path.trimExt(path.basename(name)));
    // remove duplicates
    const uniqueNames = new Set(allNames);
    allNames.length = 0;
    uniqueNames.forEach((name) => allNames.push(name));
    return allNames;
}
//# sourceMappingURL=pixiManifest.js.map