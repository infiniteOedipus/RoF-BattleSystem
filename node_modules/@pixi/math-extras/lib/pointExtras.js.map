{"version":3,"file":"pointExtras.js","sources":["../src/pointExtras.ts"],"sourcesContent":["import { ObservablePoint, Point } from '@pixi/core';\n\nimport type { IPointData } from '@pixi/core';\n\nconst mixins: any = {\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    add<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    subtract<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    multiply<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.Point#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.ObservablePoint#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    multiplyScalar<T extends IPointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    dot(other: IPointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    cross(other: IPointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.Point#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    normalize<T extends IPointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.Point#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    project<T extends IPointData>(onto: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.Point#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    reflect<T extends IPointData>(normal: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as IPointData as T;\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    }\n};\n\nObject.assign(Point.prototype, mixins);\nObject.assign(ObservablePoint.prototype, mixins);\n"],"names":["Point","ObservablePoint"],"mappings":"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"}